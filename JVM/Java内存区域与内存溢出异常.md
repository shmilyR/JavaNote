# 运行时数据区域
Java虚拟机运行时数据区：
<img src="image/java虚拟机运行时数据区.PNG"/>
## 程序计数器
1. 程序计数器时一块较小的内存空间，它可以看作是当前线程所执行的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、跳转、循环、异常处理、线程恢复等基础功能都需要这个计数器来完成。
2. 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后都能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这类内存区域被称为"线程私有"的内存；
3. 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果为Native方法，这个计数器的值为空(undefined).
## Java虚拟机栈
1. Java虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链表、方法出口等信息。每一个方法从调用直至完成执行的过程，就对应着一个栈帧在虚拟机中入栈和出栈的过程。
2. 局部变量表存放了编译期可知的各种基本数据类型、对象引用类型(它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此位置相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。
3. long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间，不会改变局部变量表的大小。
4. 栈区域的两种异常:
    1. StackOverflowError:线程请求的栈深度大于虚拟机所允许的深度；
    2. OutOfMemoryError:如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存。
## Java堆
1. Java堆是Java虚拟机所管理的内存中的最大一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
2. Java堆是垃圾收集器管理的主要区域(GC堆)。
3. Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
4. 异常：OutOfMemoryError:堆中没有内存完成实例分配，并且堆也无法再扩展。
## 方法区
是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。
## 运行时常量池
是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。  
运行时常量池相对于Class文件常量池的另外一个重要特征是：具备动态性。
## 异常处理方法
### Java堆溢出
1. 溢出原因：Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制就会产生内存溢出异常。
2. 解决方案：(1) 先通过内存内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是分清楚到底是内存泄漏还是内存溢出。(2 )如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了类型对象的类型信息及引用链的信息，就可以比较准确的定位出泄露代码的位置如果不存在泄露，换句话说就是内存中的对象确实都还活着，那就应该检查虚拟机的堆参数(-Xmx与-Xms),与机器物理内存对比看是否还可以调大，从代码上看是否还存在哪些对象的生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
### -Xmx,-Xms与-Xss
Xms 是指设定程序启动时占用内存大小。一般来讲，大一点，程序会启动的快一点，但是也可能会导致机器暂时变慢。  
Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。  
Xss 是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。
三个参数的设置都是默认以Byte为单位的，也可以在数字后面添加[k/K]或者[m/M]来表示KB或者MB。而且更不能超过机器本身的内存大小。  
-Xms 为jvm启动时分配的内存，比如-Xms200m，表示分配200M  
-Xmx 为jvm运行过程中分配的最大内存，比如-Xms500m，表示jvm进程最多只能够占用500M内存  
-Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M  
Xss：每个线程的stack大小（栈）  
Xmx：JAVA HEAP的最大值、默认为物理内存的1/4  
Xms：JAVA HEAP的初始值，server端最好Xms与Xmx一样  
Xmn：JAVA HEAP young区的大小  
XX:PermSize：设定内存的永久保存区域  
XX:MaxPermSize：设定最大内存的永久保存区域
### 虚拟机栈和本地方法区溢出

