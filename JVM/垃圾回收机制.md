 ## 垃圾收集所关注的是Java堆和方法区这部分的内存。  
 原因：程序计数器、虚拟机栈、本地方法栈3个区域是“线程私有”的，在方法结束或线程结束后，内存自然回收。而Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的。
 # 判断对象是否"已死"
 垃圾收集器对"堆"进行回收  
 "对象已死"：不可能再被任何途径使用的对象。  
 + 引用计数算法：
    +  算法描述：给对象中添加一个引用计数器，每当有一个计数器引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数值为0的对象就是不可能再被使用的。
    +  主流的Java虚拟机并没有采用此方法，原因：难以解决对象之间相互循环引用的问题。
+ 可达性分析算法
    + 算法思想：通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为"引用链"，当一个对象到GC Roots没有任何引用链相连(用图论的话说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。
    + 在Java中，可作为GC Roots的对象包括：
        + 虚拟机栈(栈帧中的本地变量表)中引用的对象；
        + 方法区中静态属性引用的对象；
        + 方法区中常量引用的对象；
        + 本地方法栈中JNI引用的对象。
    + 即使在可达性分析算法中不可达的对象，也并非“非死不可”，他们只是暂时处于了“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后，发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是：此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这种情况都视为"没有必要执行"。
    + 如果这个对象被判定为有必要执行finzlize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程区执行。这里的"执行"是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是：如果一个对象在finzlize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其它对象永久处于等待，甚至导致整个内存回收系统崩溃。finzlize()方法是对象逃脱死亡命令的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象在finzlize()中成功拯救自己，只需要重新与引用链上的任何一个对象建立关联即可。  
<font color="red">一个对象的finalize()方法最多只会被系统自动的调用一次。</font>
+ 总结：判定对象是否存活都与"引用"有关。   
  引用的分类：
  + 强引用：
  + 软引用：
  + 弱引用：
  + 虚引用：
# 回收方法区
永久代的垃圾收集主要回收两部分内容：废弃的常量和无用的类。    
无用的类的判断：
+ 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
+ 加载该类的ClassLoder都已经被回收；
+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
# 垃圾收集算法
+ 标记-清除算法：
    + 分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    + 主要不足：
        1. 效率问题："标记"和"清除"两个过程的效率都不高；
        2. 空间问题：标记清除之后，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次的垃圾收集动作。
+ 复制算法(新生代)
    + 出现的原因：为了解决效率问题。
    + 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单、运行高效。
    + 代价：将内存缩小为原来的一半。
+ 标记-整理算法(老年代)  
    过程仍与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。
+ 分代收集算法  
根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这个就可以根据各个年代的特点采用最适合的收集算法。
<font color="yellow">新生代对象存活率低，采用复制算法；老年代对象存活率高、没有额外空间对他进行分配担保，使用"标记-清理"。</font>
# 垃圾收集器
+ Serial收集器(单线程)
    + "单线程"的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
    + 优点：简单高效、对于限定的单个CPU的环境来说，Serial收集器由于没有线程交互的开销。
+ ParNew收集器(运行在Server模式下的虚拟机中首选的新生代收集器)
    + Serial收集器的多线程版本。除了使用多条线程进行垃圾收集之外，其余行为包括：Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等与Serial收集器完全一样。
    + 除了Serial收集器外，目前只有它能够与CMS收集器配合工作。  
<font color="red">并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态；  
并发：指用户线程与垃圾收集线程同时执行(但并不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
</font>
+ Parallel Scavenge收集器(新生代))  
CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间而Parallel Seavenge收集的目标是则是尽可能达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间和CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。  
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互任务。  
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。  
    + MaxGCPauseMills参数：允许的值是一个大于0的毫秒数，收集器将尽可能的保证内存回收花费的时间不超过设定值。
    + GCTimeRatio:参数的值是一个大于0且小于100的整数，也就是垃圾收集时间占总总时间的比率，相当于吞吐量的倒数。  
除上述参数外，还有一个参数-XX：+UseAdaptiveSizePolicy：是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例、晋升老年代对象大小等细节参数了，虚拟机会根据当前系统的运行情况收集收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称作GC自适应的调节策略。
+ Serial Old收集器
+ Parallel Old收集器
+ CMS收集器("标记-收集"算法))  
是一种以获取最短回收停顿时间为目的收集器。过程分为4个步骤：
    + 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
    + 并发标记：就是进行GC Roots Tracing的过程。
    + 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    + 并发清除：  
整个过程中耗时最长的并发标记和并发清楚过程收集器线程都可以与用户线程一起工作，所以，从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的。  
CMS的主要优点：并发收集、低停顿。  
CMS的主要缺点：
        + CMS收集器对CPU资源非常敏感。
        + CMS收集器无法处理浮动垃圾。浮动垃圾：出现在标记过程之后的垃圾，CMS无法再当次收集中处理掉他们，只好留待下一次GC时再清理掉。
        + "标记-清除"算法的缺点，收集结束时会有大量空间碎片产生。
+ G1收集器  
是一款面向服务端应用的垃圾回收机制。G1的特点：
    + 并行与并发：
    + 分代收集：
    + 空间整合：
    + 可预测的停顿：
