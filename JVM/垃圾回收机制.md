 ## 垃圾收集所关注的是Java堆和方法区这部分的内存。  
 原因：程序计数器、虚拟机栈、本地方法栈3个区域是“线程私有”的，在方法结束或线程结束后，内存自然回收。而Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的。
 # 判断对象是否"已死"
 垃圾收集器对"堆"进行回收  
 "对象已死"：不可能再被任何途径使用的对象。  
 + 引用计数算法：
    +  算法描述：给对象中添加一个引用计数器，每当有一个计数器引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数值为0的对象就是不可能再被使用的。
    +  主流的Java虚拟机并没有采用此方法，原因：难以解决对象之间相互循环引用的问题。
+ 可达性分析算法
    + 算法思想：通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为"引用链"，当一个对象到GC Roots没有任何引用链相连(用图论的话说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。
    + 在Java中，可作为GC Roots的对象包括：
        + 虚拟机栈(栈帧中的本地变量表)中引用的对象；
        + 方法区中静态属性引用的对象；
        + 方法区中常量引用的对象；
        + 本地方法栈中JNI引用的对象。
    + 即使在可达性分析算法中不可达的对象，也并非“非死不可”，他们只是暂时处于了“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后，发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是：此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这种情况都视为"没有必要执行"。
    + 如果这个对象被判定为有必要执行finzlize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程区执行。这里的"执行"是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是：如果一个对象在finzlize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其它对象永久处于等待，甚至导致整个内存回收系统崩溃。finzlize()方法是对象逃脱死亡命令的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象在finzlize()中成功拯救自己，只需要重新与引用链上的任何一个对象建立关联即可。  
<font color="red">一个对象的finalize()方法最多只会被系统自动的调用一次。</font>
+ 总结：判定对象是否存活都与"引用"有关。   
  引用的分类：
  + 强引用：
  + 软引用：
  + 弱引用：
  + 虚引用：
# 回收方法区
永久代的垃圾收集主要回收两部分内容：废弃的常量和无用的类。    
无用的类的判断：
+ 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
+ 加载该类的ClassLoder都已经被回收；
+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
# 垃圾收集算法
+ 标记-清除算法：
    + 分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    + 主要不足：
        1. 效率问题："标记"和"清除"两个过程的效率都不高；
        2. 空间问题：标记清除之后，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次的垃圾收集动作。
+ 复制算法(新生代)
    + 出现的原因：为了解决效率问题。
    + 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单、运行高效。
    + 代价：将内存缩小为原来的一半。
+ 标记-整理算法(老年代)  
    过程仍与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。
+ 分代收集算法  
根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这个就可以根据各个年代的特点采用最适合的收集算法。
<font color="yellow">新生代对象存活率低，采用复制算法；老年代对象存活率高、没有额外空间对他进行分配担保，使用"标记-清理"。</font>
# 垃圾收集器
+ Serial收集器(单线程)
    + "单线程"的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
    + 优点：简单高效、对于限定的单个CPU的环境来说，Serial收集器由于没有线程交互的开销。
+ ParNew收集器
    + Serial收集器的多线程版本。除了使用多条线程进行垃圾收集之外，其余行为包括：Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等与Serial收集器完全一样。
+ Parallel Scavenge收集器
+ Serial Old收集器
+ Parallel Old收集器
+ CMS收集器
+ G1收集器
