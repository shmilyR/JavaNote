# Java对象的创建过程
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。再类加载检查通过之后，接下来虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。(这一操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，程序能直接访问到这些字段的数据类型所对应的零值)。接下来，虚拟机对对象进行必要的设置。至此，在虚拟机角度，一个对象创建完毕。从Java角度，对象创建才刚刚开始，init()方法还没有执行，所有的字段还为0. 
划分的两种方法：
+ "指针碰撞"：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存都放在另外一边，中间放着一个指针作为分界点的指示器，那所分配内存仅仅就是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
+ “空闲列表”：如果Java堆中的内存并不是规整的，已使用的内存与空闲的内存相互交错，就没有办法进性指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。  
除划分可用空间外，还有一个需要考虑的问题是对象创建在虚拟机中是非常频繁的，即使是仅仅修改一个指针的指向，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决方案：
+ 对分配内存空间的动作进性同步处理（实际上虚拟机采用CAS配上失效重试的方式保证更新操作的原子性）
+ 把内存分配的动作按照线程划分在不同的空间之中进性，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。
# 对象的内存布局
对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。
### 对象头  
HotSpot的对象的内存布局：(分为两部分信息)
+ 用于存储对象运行自身的运行时数据。（Mark Word）
+ 用于存储指向方法区对象类型数据的指针。（如果是数组对象，还会有一个额外的部分用于存储数组长度）   
对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存中存储尽量多的信息，它会根据对象的状态复用自己的存储空间。
<table border="2" align="center">
<h4 align="center">HotSpot虚拟机对象头</h4>
<tr>
    <th>存储内容</th>
    <th>标志位</th>
    <th>状态</th>
</tr>
<tr>
    <td align="center">对象哈希码、对象分代年龄</td>
    <td align="center">01</td>
    <td align="center">未锁定</td>
</tr>
<tr>
    <td align="center">指向锁记录的指针</td>
    <td align="center">00</td>
    <td align="center">轻量级锁定</td>
</tr>
<tr>
    <td align="center">指向重量级锁的指针</td>
    <td align="center">10</td>
    <td align="center">膨胀(重量级锁定)</td>
</tr>
<tr>
    <td align="center">空，不需要记录信息</td>
    <td align="center">11</td>
    <td align="center">GC标记</td>
</tr>
<tr>
    <td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td>
    <td align="center">01</td>
    <td align="center">可偏向</td>
</tr>
</table>

### 实例数据
是对en象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类中继承下来，还是在子类中定义的，都需要记录下来。  
这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。
# 对象的访问定位
Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。对象访问方式取决于虚拟机实现而定。两种主流的访问方式：句柄和直接指针。
+ 句柄：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；  
使用句柄的好处是：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
+ 直接指针：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。  
直接指针的好处就是速度更快，节省了一次指针定位的时间开销。