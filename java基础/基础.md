# final finalize() finally
## final
+ final修饰类：说明此类不能被继承；
+ final修饰方法：说明此方法不可以被重写 private被隐式的指定为final方法
+ final修饰变量：如果是基本数据类型，则此变量不能再被更改；如果是引用数据类型，则在对其初始化后不能再让其指向另一个对象。
## finally
是在异常处理时提供finally来执行任何清除操作。不管有没有异常抛出、捕获，finally块都会被执行。
## finalize()
是方法名。java技术允许使用finalize()方法在垃圾收集器中将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。是object中的方法，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。但是一个对象的finalize()方法最多只被系统调用一次。
# String StringBuffer StringBuilder
## String(不可变字符串) 
+ String中的join()方法：可以使多个字符型串放在一起。
```java
String strings = String.join("/","s","l","m","n");
System.out.println(strings);
```
输出结果：
```
s/l/m/n
```
+ 编译器可以让字符串共享。
+ 空串和null
    + 空串:长度为0的字符串。是一个Java对象，有自己的串长度(0)和内容(空)。
    + String变量还可以存放一个特殊的值，名为null,表示目前没有任何对象与该变量关联。
+ String str=""与String str = new String("")
    + String str = ""；  
    在class文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做常量池。在运行期间对应着方法区的运行池常量池，运行期间字面常量""被存储在运行时常量池，通过这种方式将String对象跟引用绑定，JVM执行引擎会先在运行时常量池中查找是否存在相同的字面常量，如果存在，则直接引用，如果不存在，则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。
    + String str = new String("");  
    new生成的对象在堆区，无论是否存在，都会新创建一个对象。因此，new出来的，一定是不同的对象。
<table border="2">
    <tr>
        <th></th>
        <th>String</th>
        <th>StringBuffer</th>
        <th>StringBuilder</th>
    </tr>
    <tr>
        <td>执行速度</td>
        <td>最慢</td>
        <td>次之</td>
        <td>最快</td>
    </tr>
     <tr>
        <td>线程安全</td>
        <td></td>
        <td>线程安全</td>
        <td>线程不安全</td>
    </tr>
     <tr>
        <td></td>
        <td>常量</td>
        <td>变量</td>
        <td>变量</td>
    </tr>
    <tr>
        <td>适用范围</td>
        <td>少量字符串操作</td>
        <td>多线程下字符缓冲区进行大量操作</td>
        <td>单线程下字符缓冲区进行大量操作</td>
    </tr>
</table>

# Java特性
## 封装
从形式上看，封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程称为方法。对于每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态，无论何时，只要向对象发送一个消息，它的状态就有可能发生变化。  
实现封装的关键在于绝对不让类中的方法直接地访问其他类地实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了"黑盒"特征，这是提高重用性和可靠性地关键。这意味着一个类可以全面地改变存储数据地方式，只要仍旧使用同样地方法操作数据，其他对象就不会知道或介意所发生地变化。  
封装的优点：可以改变内部实现，除了该类的方法外，不会影响其他代码；
## 继承

## 多态

## 抽象
# 类
## 对象的三个主要特征
+ 对象的行为
+ 对象的状态
+ 对象标识
## 类与类之间的关系
+ 依赖
+ 聚合
+ 继承

一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
# 静态变量 静态代码块 主函数 成员变量 构造代码块 构造函数执行顺序
+ 静态代码块：代码在项目启动的时候就执行，这种代码是主动执行的，而且只执行一次。常被用做类属性的初始化。
```java
static{
    //执行体
}
```
+ 静态方法：在类加载的时候就已经加载，在类名调用时才执行，这种代码是被动执行的。  
<font color="color">注意：静态方法里只能调用同类中其他静态成员；不能以任何方式引用this和super关键字，因为静态方法使用前不需创建任何对象实例，因此就不存在this.</font>
+ 静态变量：属于整个类的变量而不是某个对象，任何方法都不能声明static变量。
## 类的加载
+ 什么时候加载？
    + 类的加载是通过类加载器(ClassLoader)完成的；
    + 两种情况加载类：
        + 只要有其它类引用了它就加载；
        + 等到类初始化发生的时候才加载。
    + 静态加载：new ClassName();编译时就提供
    + 动态加载：Class.forName("ClassName");编译时可缺席
+ 什么时候初始化？  
加载完类后类的初始化就会发生，会初始化所有的静态成员。
+ 加载顺序  
加载类时初始化顺序：按顺序加载对象的静态属性-->再加载静态代码块-->加载类的主函数  
对象实例化时加载顺序：加载对象的非静态属性-->非静态代码块-->构造方法  
有父类的情况：加载父类(初始化步骤)-->加载子类(初始化)-->加载父类(实例化)-->加载子类(实例化)
# 抽象类和接口的区别
+ 抽象类：是用来捕捉子类的通用特性的。不能被实例化，只能被用作子类的超类，抽象类是被用来创建继承层级里子类的模板。
+ 接口：接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象抽象方法。这就像契约模式,如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。
<table border="2">
    <caption>抽象类和接口的对比</caption>
    <tr>
        <th>参数</th>
        <th>抽象类</th>
        <th>接口</th>
    </tr>
    <tr>
        <td align="center">默认的实现方法</td>
        <td align="center">它可以有默认的实现方法</td>
        <td align="center">接口完全是抽象的，它根本不存在方法的实现</td>
    </tr>
    <tr>
        <td align="center">实现</td>
        <td align="center">子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
        <td align="center">子类使用关键字implents来实现接口。它需要提供接口中所有声明的方法的实现。</td>
    </tr>
    <tr>
        <td align="center">构造器</td>
        <td align="center">抽象类可以有构造器</td>
        <td align="center">接口不能有构造器</td>
    </tr>
    <tr>
        <td align="center">与正常Java类的区别</td>
        <td align="center">除了不能实例化抽象类之外，和普通的Java类没有区别</td>
        <td align="center">接口是完全不同类型。</td>
    </tr>
    <tr>
        <td align="center">访问修饰符</td>
        <td align="center">抽象方法可以有public、protected和default这些修饰符</td>
        <td align="center">接口默认修饰符是public.不可以使用其他修饰符</td>
    </tr>
    <tr>
        <td align="center">main方法</td>
        <td align="center">抽象方法可以有main方法并且我们可以运行它</td>
        <td align="center">接口没有main方法，因此我们不能运行它</td>
    </tr>
    <tr>
        <td align="center">多继承</td>
        <td align="center">抽象方法可以继承一个类和实现多个接口</td>
        <td align="center">接口只可以继承一个或多个其它接口</td>
    </tr>
    <tr>
        <td align="center">速度</td>
        <td align="center">比接口速度要快</td>
        <td align="center">接口是稍微有点慢的，因为它需要时间去寻找类中实现的方法。</td>
    </tr>
    <tr>
        <td align="center">添加新方法</td>
        <td align="center">在往抽象类中添加新的方法，可以给它提供默认的实现。因此，不需要改变现在的代码。</td>
        <td align="center">往接口中添加方法，必须改变实现该接口的类。</td>
    </tr>
</table>

# 什么时候使用抽象类和接口？
+ 如果拥有一些方法并且想让他们中的一些有默认实现，那么必须使用抽象；
+ 如果想实现多重继承，那么必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。
+ 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本内容并且使用接口，那么就需要改变所有实现了该接口的类。