# final finalize() finally
## final
+ final修饰类：说明此类不能被继承；
+ final修饰方法：说明此方法不可以被重写 private被隐式的指定为final方法
+ final修饰变量：如果是基本数据类型，则此变量不能再被更改；如果是引用数据类型，则在对其初始化后不能再让其指向另一个对象。
## finally
是在异常处理时提供finally来执行任何清除操作。不管有没有异常抛出、捕获，finally块都会被执行。
## finalize()
是方法名。java技术允许使用finalize()方法在垃圾收集器中将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。是object中的方法，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。但是一个对象的finalize()方法最多只被系统调用一次。
# String StringBuffer StringBuilder
## String(不可变字符串) 
+ String中的join()方法：可以使多个字符型串放在一起。
```java
String strings = String.join("/","s","l","m","n");
System.out.println(strings);
```
输出结果：
```
s/l/m/n
```
+ 编译器可以让字符串共享。
+ 空串和null
    + 空串:长度为0的字符串。是一个Java对象，有自己的串长度(0)和内容(空)。
    + String变量还可以存放一个特殊的值，名为null,表示目前没有任何对象与该变量关联。
+ String str=""与String str = new String("")
    + String str = ""；  
    在class文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做常量池。在运行期间对应着方法区的运行池常量池，运行期间字面常量""被存储在运行时常量池，通过这种方式将String对象跟引用绑定，JVM执行引擎会先在运行时常量池中查找是否存在相同的字面常量，如果存在，则直接引用，如果不存在，则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。
    + String str = new String("");  
    new生成的对象在堆区，无论是否存在，都会新创建一个对象。因此，new出来的，一定是不同的对象。
<table border="2">
    <tr>
        <th></th>
        <th>String</th>
        <th>StringBuffer</th>
        <th>StringBuilder</th>
    </tr>
    <tr>
        <td>执行速度</td>
        <td>最慢</td>
        <td>次之</td>
        <td>最快</td>
    </tr>
     <tr>
        <td>线程安全</td>
        <td></td>
        <td>线程安全</td>
        <td>线程不安全</td>
    </tr>
     <tr>
        <td></td>
        <td>常量</td>
        <td>变量</td>
        <td>变量</td>
    </tr>
    <tr>
        <td>适用范围</td>
        <td>少量字符串操作</td>
        <td>多线程下字符缓冲区进行大量操作</td>
        <td>单线程下字符缓冲区进行大量操作</td>
    </tr>
</table>

# Java特性
## 封装
从形式上看，封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，操纵数据的过程称为方法。对于每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态，无论何时，只要向对象发送一个消息，它的状态就有可能发生变化。  
实现封装的关键在于绝对不让类中的方法直接地访问其他类地实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了"黑盒"特征，这是提高重用性和可靠性地关键。这意味着一个类可以全面地改变存储数据地方式，只要仍旧使用同样地方法操作数据，其他对象就不会知道或介意所发生地变化。  
封装的优点：可以改变内部实现，除了该类的方法外，不会影响其他代码；
## 继承

## 多态

## 抽象
# 类
## 对象的三个主要特征
+ 对象的行为
+ 对象的状态
+ 对象标识
## 类与类之间的关系
+ 依赖
+ 聚合
+ 继承

一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
# 静态变量 静态代码块 主函数 成员变量 构造代码块 构造函数执行顺序
+ 静态代码块：代码在项目启动的时候就执行，这种代码是主动执行的，而且只执行一次。常被用做类属性的初始化。
```java
static{
    //执行体
}
```
+ 静态方法：在类加载的时候就已经加载，在类名调用时才执行，这种代码是被动执行的。  
<font color="color">注意：静态方法里只能调用同类中其他静态成员；不能以任何方式引用this和super关键字，因为静态方法使用前不需创建任何对象实例，因此就不存在this.</font>
+ 静态变量：属于整个类的变量而不是某个对象，任何方法都不能声明static变量。
## 类的加载
+ 什么时候加载？
    + 类的加载是通过类加载器(ClassLoader)完成的；
    + 两种情况加载类：
        + 只要有其它类引用了它就加载；
        + 等到类初始化发生的时候才加载。
    + 静态加载：new ClassName();编译时就提供
    + 动态加载：Class.forName("ClassName");编译时可缺席
+ 什么时候初始化？  
加载完类后类的初始化就会发生，会初始化所有的静态成员。
+ 加载顺序  
加载类时初始化顺序：按顺序加载对象的静态属性-->再加载静态代码块-->加载类的主函数  
对象实例化时加载顺序：加载对象的非静态属性-->非静态代码块-->构造方法  
有父类的情况：加载父类(初始化步骤)-->加载子类(初始化)-->加载父类(实例化)-->加载子类(实例化)
