# 二维数组查找
> 问题描述：二维数组从左至右、从上至下，递增排好序。  
> 问题要求：输入一个数字，查找数组中是否有这个数字。  
<table align="center">
    <tr>
        <td>1</td>
        <td>2</td>
        <td>8</td>
        <td>9</td>
    </tr>
    <tr>
        <td>2</td>
        <td>4</td>
        <td>9</td>
        <td>12</td>
    </tr>
    <tr>
        <td>4</td>
        <td>7</td>
        <td>10</td>
        <td>13</td>
    </tr>
    <tr>
        <td>6</td>
        <td>8</td>
        <td>11</td>
        <td>15</td>
    </tr>
</table>

+ 初看这个题目，以为遍历最简单，快捷。实际上，遍历存在很大的问题：
    1. 题目中已经说明数组是排好序的，如果直接遍历，那问题说明将无意义，没有充分利用题目信息。😜
    2. 时间复杂度问题：直接遍历是O(n^2) 。
因此，遍历并不是一个很好的选择
+ 书上给出的思路是：由于二维数组已经是排好序的，可以从二维数组的四个角中任选一个角，将此角的元素a[i][j]与要求的数字num进行比较。此时，分三种情况：事件复杂度O(n)
    1. a[i][j] > num : a[i][j--]
    2. a[i][j] < num : a[i++][j]
    3. a[i][j] = num : 此时编程结束.
```c
int find(int arr[4][4],int m,int n,int num) {
	while (arr[m][n] != num && m >= 0 && n < 4 && n >= 0 && m < 4) {
		if (arr[m][n] > num) {
			n--;
		} else if (arr[m][n] < num) {
			m++;
		}
	}
	if (arr[m][n] == num) {
		return 1;
	}
	return 0;
}
```
> 代码分析：  

&emsp;&emsp;代码的局限性：代码只能根据自己选定的角元素来编写，不具有灵活性。
+ 根据书上的思路，给出自己的想法：由于题目中已经说明，数组是排好序的，最易想到的是二分法查找。事件复杂度O(logn).  
<font size="6"><b>二分法查找</b></font>  
前提是 ： 数组是排好序的。适用于数据量大。需要有一个start、end、middle.  



