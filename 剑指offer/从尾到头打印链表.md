# 从尾到头打印链表
> 问题描述：给定链表，从尾到头打印出其每个节点值。
> 问题前提：创建链表，输出链表  
+ 如果没有给定链表，可以在在创建链表时，直接使用“头插法”，直接输出链表即就是逆向输出的链表。  
+ 如果没有给定链表，则需要考虑，更换思路，从尾到头，就相当于“先进后出”,此时应该考虑到“栈”。因此我们可以用“栈”来实现题目要求。 
+ 由于可以用“栈”来实现，我们易于想到使用递归来实现链表的逆向输出。  
但是在调用时，我们要注意：传参数时，有带头链和不带头链的区别：如果是带头链，此时需要跳过头结点输出，所有，应该传的是list->next;如果是不带头链，则不需要考虑这个问题。
```c
//用递归实现链表的逆向输出
void printWithRecursion(Linked *list) {
	//当list->next != null时，就选择再次调用此函数，即递归。
	if (list != NULL) {
		printWithRecursion(list->next);
		printf("%5d", list->element);
	}
}
```  
# 递归  
 递归：一定要先判断结束的条件，否则就会死循环。  （在一个函数的内部调用自身）  
  然后，满足条件时，进行递归调用，直至不满足递归调用的条件，就会返回上一次的递归调用，执行上一次递归调用之后的代码，直到第一次递归调用结束。因此，递归是栈的一个很好的应用。 
+ 递归的优缺点：  
	+ 优点：代码简洁
	+ 缺点：  
		1、由于递归是对函数本身的调用，而函数的调用有时间和空间的消耗，每一次的调用，都需要在内存栈中分配空间以保存参数，返回地址及临时变量，而且，往栈里压入数据和弹出数据都需要时间。  
		2、调用递归时，有可能很多计算都是重复的，从而对性能产生影响。  
		3、除此之外，递归还可能引发更严重的问题：调用栈溢出。因为每一次调用递归时，都需要为其在内存栈分配空间，而每个进程的栈的容量是有限的，当递归调用层级太多时，就会超出栈的容量，从而导致调用栈溢出。