Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中锁使用的并发机制依赖于JVM的实现和CPU的指令。  
# volatile
## volatile的定义和实现原理
+ volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的"可见性"。
+ 定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内模型确保所有线程看到这个变量地值是一致的。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当，它比synchronized的使用和执行成本更低，因为它不会引起上下文切换。  
+ 有volatile时，汇编代码会多处第二行代码，带有lock前缀，带有Lock前缀的指令在多核处理器下会引发了两件事情：
    + 将当前处理器缓存行的数据写回到系统内存；
    + 这个写回内存的操作会使在其它CPU里缓存了该内存地址的数据无效。
+ 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就或向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其它处理器缓存的值还是旧的，再执行计算操作就有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
### volatile的两条实现原则：
+ Lock前缀指令会引起处理器缓存回写到内存。
+ 一个处理器的缓存回写到内存会导致其它处理器的缓存无效。
### volatile的使用优化
追加字节来优化队列出队的入队的性能。
# synchronized
+ synchronized实现同步的基础:Java中的每一个对象都可以作为锁。具体表现：
    + 对于普通同步方法，锁是当前实例对象；
    + 对于静态方法，锁是当前类的Class对象；
    + 对于同步方法块，锁是synchronized括号里配置的对象。
+ synchronized在JVM中的实现原理：JVM基于进入和退出Monitor对象来实现方法同步可代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的。
+ monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，并且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
### Java对象头
+ synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字节宽存储对象头；如果对象是非数组来行，用2字节宽来存储对象头。
+ 在JavaSE中，锁一共有4种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。
    + 偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧里存储锁偏向的线程ID，以后该进程在进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)；如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
    + 偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其它线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程不处于活动状态，则将对象头设置为无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其它线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
    + 轻量级锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其它线程竞争锁。当前线程便尝试使用自旋来获取锁。
    + 轻量级锁解锁：轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
    + 因为自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其它线程试图获得锁时，都会被阻塞主，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的争夺锁。
    + 锁的优缺点对比：
<table border="2">
    <tr>
        <th>锁</th>
        <th>优点</th>
        <th>缺点</th>
        <th>适用场景</th>
    </tr>
    <tr>
        <td align="center">偏向锁</td>
        <td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距</td>
        <td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
        <td align="center">适用于只有一个线程访问块的场景</td>
    </tr>
    <tr>
        <td align="center">轻量级锁</td>
        <td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td>
        <td align="center">如果始终得不到锁竞争的线程，使用自旋消耗CPU</td>
        <td align="center">追求响应时间，同步块执行速度非常快
        <tr>
        <td align="center">重量级锁</td>
        <td align="center">线程竞争不使用自旋，不会消耗CPU</td>
        <td align="center">线程阻塞，响应时间缓慢</td>
        <td align="center">追求吞吐量，同步块执行速度较长</td>
    </tr>
</table>