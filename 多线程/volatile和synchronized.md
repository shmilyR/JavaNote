Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的。
# 并发编程中的三个概念
+ 原子性：
    + 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write.大致可以认为基本数据类型的访问读写是具备原子性的(long和double的非原子性协议)
    + 如果还需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作。尽管虚拟机未把lock和unlock操作直接开放给用户，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式的使用这两个操作，反映在Java代码中就是同步块，synchronized关键字。
+ 可见性：
    + 指一个线程修改了共享变量的值，其它线程能够立即得到这个修改。Java内存模型是通过在变量修改后将主值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。(普通变量和volatile变量都是如此)
    + 普通变量和volatile变量的区别就是：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
    + final的可见性：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把"this"的引用传递出去(this引用逃逸：其它线程有可能通过这个引用访问到了"初始化了一半"的对象)，那在其它线程中就能看到final字段的值。
+ 有序性：如果在本线程内观察，所有的操作都是有序的；(线程内表现为串行的语义)如果在一个线程中观察另一个线程，素有的操作都是无序的("指令重排序现象"和"工作内存与主内存同步延迟状态")。
# volatile
+ 是Java虚拟机提供的最轻量级的同步机制。
+ 当一个变量定义为volatile之后，他将具备两种特性：
    + 保证此变量对所有线程的可变性；(这里的可见性是指：当一条线程修改了这个这个变量的值，新值对于其它线程来说是可以立即得知的)。
        + volatile变量在各个线程的工作内存中不存在一致性问题。
    + 禁止指令重排序优化。
# synchronized
+ 在synchronized块的操作具备原子性；
+ synchronized的可见性是由对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(store、write操作)。
+ synchronized的有序性："一个变量在同一时刻只允许一条线程对其进行lock操作"。决定了持有同一个锁的两个同步块只能串行的进入。