# 上下文切换
即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，时间片一般是几十毫秒。  
CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存再到加载的过程就是一次上下文切换。  
## 如何减少上下文切换？
减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。  
+ 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以，多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
+ CAS算法：
+ 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会使大量的线程都处于等待状态。
+ 协程：在单线程里实现多任务调度，并在单线程里维持多个任务间的切换。 
# 死锁
定义：死锁是指多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进。
## 死锁产生的原因
+ 系统资源的竞争：通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。只有对不可剥夺资源的竞争，才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。
+ 进程推进顺序非法：进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。
+ 信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使这些进程间无法继续向前推进。
## 死锁产生的必要条件
+ 互斥条件：进程要求对所分配的资源，进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其它进程请求该资源，则请求进程只能等待。
+ 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其它进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)
+ 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
+ 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。  
产生死锁的例子:
```java
public class DeadLock implements Runnable{
    public int flag = 1;
    public static Object o1 = new Object(),o2 = new Object();


    @Override
    public void run() {
        System.out.println("flag="+flag);
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println("1");
                }
            }
        }
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("0");
                }
            }
        }
    }

    public static void main(String[] args) {
        DeadLock deadLock1 = new DeadLock();
        DeadLock deadLock2 = new DeadLock();
        deadLock1.flag = 1;
        deadLock2.flag = 0;
        new Thread(deadLock1).start();
        new Thread(deadLock2).start();
    }
}
```
## 如何避免死锁
+ 加锁顺序(线程按照一定的顺序加锁)
+ 加锁时限(线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求)。
+ 死锁检测
### 加锁顺序
当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生，如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。  
按照线程加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁(并对这些锁做适当的排序)，但有些时候是无法预知的。  
### 加锁时限
是在尝试获得锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中，若超过了这个时限，该线程则放弃对该锁的请求。若一个线程没有在给定的时限内成功获得所需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。(加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。  
如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是有可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试地超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是多个锁，因为这些线程等待相等地重试时间地概率就高地多。  
超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。  
这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。
### 死锁检测
主要是针对那些不可能时限按序加锁并且锁超时也不可行的场景。  
每当一个线程获得了锁，会在线程和锁相关的数据结构中将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。  
当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。  
四个线程之间锁占有和请求的关系图： 
<img src="img/死锁检测.png"/>  
当检测出死锁时，一个可行的做法是释放所有的锁，回退，并且等待一段随机时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会因为加锁的请求超市了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，他们还是会重复的死锁。  
一个更好的方案是：给这些线程设置优先级，让一个或几个线程回退，剩下的线程就像没发生死锁一样继续保持着他们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是拥有更高的优先级。为了避免这个问题，可以在死锁发生的时候设置随机的优先级。 
# 资源限制的挑战
+ 什么是资源限制：资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。
+ 资源限制引发的问题：在并发编程中，将代码执行速度加快的原则是：将代码中串行执行的部分变成并发执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。
+ 如何解决资源限制问题？对于硬件资源限制，可以考虑用集群并行执行程序。既然单机的资源有限，那么就在多机上运行。对于软件资源限制，可以考虑使用资源池将资源复用。
+ 在资源限制情况下进行并发编程：根据不同的资源限制调整程序的并发度。