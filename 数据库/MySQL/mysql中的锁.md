# 锁
## 什么是锁？
+ 锁机制用于管理对共享资源的并发访问。InnDB存储引擎会在行级别上对表数据上锁。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。
+ InnoDB存储引擎提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。
## lock和latch
+ latch一般称为闩锁(轻量级得锁)，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex(互斥量)和rwlock(读写锁).其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。
+ lock的对象时数据，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放(不同事务隔离级别释放的时间可能不同)。Lock是有死锁机制的。
<table border="2">
<tr>
    <th></th>
    <th align="center">lock</th>
    <th align="center">latch</th>
</tr>
<tr>
    <td  align="center">对象</td>
    <td  align="center">事务</td>
    <td  align="center">线程</td>
</tr>
    <tr>
    <td  align="center">保护</td>
    <td  align="center">数据库内容</td>
    <td  align="center">内存数据结构</td>
</tr>
    <tr>
    <td  align="center">持续时间</td>
    <td  align="center">整个事务过程</td>
    <td  align="center">临界资源</td>
</tr>
    <tr>
    <td  align="center">模式</td>
    <td  align="center">行锁、表锁、意向锁</td>
    <td  align="center">读写锁、互斥量</td>
</tr>
    <tr>
    <td  align="center">死锁</td>
    <td  align="center">通过waits-for graph、time out等机制进行死锁检测和处理</td>
    <td  align="center">无死锁检测与处理机制。仅通过应用程序加锁的顺序保证无死锁的情况发生</td>
</tr>
    <tr>
    <td  align="center">存在于</td>
    <td  align="center">Lock Mananger的哈希表中</td>
    <td  align="center">每个数据结构的对象中</td>
</tr>
</table>

# InnoDB存储引擎中的锁
+ InnoDB存储引擎实现了如下两种标准的行级锁：
    + 共享锁：允许事务读一行数据
    + 排他锁：允许事务删除或更新一行数据
+ 共享锁和排他锁的兼容性：
    <table border="2">
        <tr>
            <th></th>
            <th>X</th>
            <th>S</th>
        </tr>
        <tr>
            <td>X</td>
            <td>不兼容</td>
            <td>不兼容</td>
        </tr>
            <tr>
            <td>S</td>
            <td>不兼容</td>
            <td>兼容</td>
        </tr>
    </table> 
    X锁与其他锁都不兼容，而S锁仅与S锁兼容。  
    <font color="red">S和X锁都是行锁，兼容是指对同一记录锁的兼容性情况。</font>
+ InnoDB支持多粒度锁定，这种锁定允许事务在行级别上的锁和表级别上的锁同时存在。InnoDB支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。
## 一致性非锁定读：
+ 一致性非锁定读是指InoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反的，InnoDB会去读取行的一个快照数据。
+ 快照数据是指该行的之前的版本的数据，该实现是通过undo段来完成，而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。
+ 非锁定读机制极大地提高了数据库的并发性。
+ 行多版本技术：快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据。
+ 在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB的select操作使用一致性非锁定读。
## MVCC(多版本并发控制)
+ 原因：并发读写数据库得时候，可能会发生脏读，传统的加锁方式将读写操作串行化后保证了读写的一致性，但读操作可能会被写操作阻塞，性能较低。
+ 优势：多版本并发控制技术使得大部分支持行锁的事务引擎不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非所锁定读，从而大大提高数据库系统的并发性能。
+ 主要是为Repeatable-Read事务隔离级别做的，在此隔离级别下，多个客户端所展示得数据相互隔离，互相更新不可见。
+ InnoDB实现MVCC:
    + InnoDB会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事物的创建不断递增。
    + 各种数据库操作的实现：
        + select:满足以下两个条件InnoDB会返回该行数据：
            + 该行的创建版本号小于等于当前版本号，用于保证select操作之前所有的操作已经执行落地；
            + 该行的删除版本号大于当前版本号或者为空。删除版本号大于当前版本号意味着有一个并发事务将该行删除了。
        + insert:将新插入的行的创建版本号设置为当前系统的版本号；
        + delete:将要删除的行的删除版本号设置为当前系统的版本号；
        + update:不执行原地update,而是转换成insert+delete.将旧的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。
        + 其中，写操作(insert、delete和update)执行时，需要将系统版本号递增。
    + 由于旧数据并不真正的删除，所以必须对这些数据进行清理，InnoDB会开启一个后台线程执行清理工作，具体的规则是将版本号小于当前系统版本的行删除，这个过程叫做purge.
    + 总结：通过MVCC很好的实现了事务的隔离性，可以达到repeatale-read级别，但要实现serializable则必须加锁。
+ 一致性锁定读：
## 自增长与锁
+ 在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下语句来得到计数器的值：
```
select max(auto_inc_col) from t for update
```
+ 插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称作AUTO-INC Locking.这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增值插入SQL语句后立即释放的。
+ 虽然AUTO_INC Locking从一定程度上提高了并发插入的效率，但还是存在性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成；其次，对于INSERT...SELECT的大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。
## 外键和锁
+ 外键主要用于引用完整性的约束检查。
+ 在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎会自动的对其加一个索引，因为这样可以避免表锁。
+ 对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT 父表。但是对于父表的SELECT操作。不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此此时使用的是select ... lock in share mode方式，即主动对父表加一个S锁，如果此时父表上已经这样加X锁，子表上的操作会被阻塞。
# 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。  
解决死锁的方式：
+ 最简单的是：不要有等待，将任何的等待都转化为回滚，并且事务重新开始。但是会导致并发性能的下降。
+ 超时。即当两个事务互相等待时，当一个等待时间超过设置的某一设定阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
+ wait-for-graph(等待图)：进行死锁检测。要求数据库保存以下两种信息：
    + 锁的信息链表
    + 事务等待链表  
  通过上述链表可以构造出一张图，而在这个图中，若存在回路，就代表存在死锁。  
  wait-for-graph的死锁检测通常是采用深度优先的算法实现。
+ 锁升级：是指将当前锁的粒度降低。