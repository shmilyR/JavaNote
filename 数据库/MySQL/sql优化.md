1. 创建必要的索引：在经常需要检索的字段上创建索引，比如要按照姓名进行检索，那么就应该在姓名字段上创建索引。
2. 使用预编译查询
    1. 尽量使用参数化SQL，这样可以避免SQL注入漏洞攻击
    2. 执行编译之后，以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
3. 调整where子句中的连接顺序：DBMS一般采用自下而上的顺序解析where子句，根据这个原理，表连接最好写在其他where条件之前，那些可以过滤掉最大记录数。
4. 尽量将多条SQL压缩到一条SQL中：每次执行SQL的时候都要建立网络连接，进行权限验证、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
5. 用where语句替换having语句：having只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。
6. 使用表的别名：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少由列名歧义引起的语法错误。
7. 在in和exists中，尽量使用exists，因为in不走索引。
8. 避免在索引上使用计算：
    1. 效率低：select* from person where salary*12 > 25000(salary是索引列)
    2. 效率高：select * from person where salary > 25000/12
9. 避免SQL中出现隐式类型转换：当一张表的索引字段在作为where条件的时候，如果进行了隐式类型转换，则此索引字段将会不被识别，因为隐式类型转换也属于计算，因此DBMS会使用全表扫描。
<font color="red">注意：防止检索范围过宽。</font>  
如果DBMS优化器认为检索范围过宽，那么将放弃索引查找而使用全表扫描。下面几种可能造成检索范围过宽的情况：
1. 使用is not null 或者不等于判断，可能造成优化器假设匹配的记录数太多。
2. 使用like运算符的时候，"a%"将会使用索引，而"a%c"和"%a"则会使用全表扫描，因此"a%c"和"%a"不能被有效的评估有效的数量。