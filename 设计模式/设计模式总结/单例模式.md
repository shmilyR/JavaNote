# 单例模式
+ 对象创建型模式
+ 具体实现：构造函数私有化
+ 核心思想：保证一个类，只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。
+ 提供一个全局的静态方法
+ 两种实现方法  
    + 饿汉式  static final 将person设置为常量 单、多线程都可以保证只有一个实例 比较耗费资源 （主动实例化）
    ```java
    //1、构造方法私有化，这样在创建对象时，就不可以new对象
    //2、需要一个静态的全局的拿到此对象的方法
    //3、调用两次全局方法之后，会发现，哈希值是相同的，说明是单例模式
    public class User {
        private String name;
        private static final  User user = new User();

        private User() {
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public static User getUser() {
            return  user;
        }
    }
    ```
    + 懒汉式 同步方法  需要的时候在创建（被动实例化）
    ```java
        //第一种实现方式：在全局的静态方法中，加判断
         public static SingletonPattern getSingletonPattern() {
        if (singletonPattern == null) {
            singletonPattern = new SingletonPattern();
        }
        return singletonPattern;
    }
    /**但是此时会存在一个问题：
    在多线程时，得到的会不是一个对象。 原因：在多线程环境下，多个线程一起调用该方法，每次判断都有可能是Null,此时都会创建一个新的对象，因此，可能会得到不同的对象
    解决方案：将此方法同步 即synchronized*/
    //此时，多线程环境下，也会得到同一个对象
     public static synchronized SingletonPattern getSingletonPattern() {
         //一个时间只能有一个进程判断
        if (singletonPattern == null) {
            singletonPattern = new SingletonPattern();
        }
        return singletonPattern;
    }
    有10000个线程：（假设singletonPattern不为空）
    当有一个线程进入这个方法时，其他9999个线程在函数外面等待。
    ```
    + 双重检查  同步代码块 懒汉式的改进
    ```java
        public static SingletonPattern getSingletonPattern() {
        //10000个线程同时判断的
        if (singletonPattern == null) {
            synchronized (SingletonPattern.class) {
                if (singletonPattern == null) {
                    singletonPattern = new SingletonPattern();
                }
            }
        }
        return singletonPattern;
    }
    ```
+ 关于恶汉式和懒汉式的总结：
    + 恶汉式 ：刚开始就创建，无论是否需要。
    + 懒汉式 ：需要时才会创建。懒汉式中存在一个同步方法块和同步代码块的问题：同步代码块的效率要比同步方法块要高，原因：在同步方法块和代码块中都会有一个if（）语句的判断，但是，同步方法块时，每次都是一个一个进行判断，同步代码块时，是可以多个线程同时进行判断的，这样就提高了效率。  
+ 如何在一个大型程序中找到单例类？  
    Java中并没有真正的全局变量，我们不可能仅在单一位置保存这些单例类。解决这个问题时，我们可以在程序的初始段创建单例类，并将他们作为参数传递给可能需要使用他们的各个类。  
+ 使用单例模式存在的问题：
    + 创建单例类的子类会非常困难，除非基类单例类尚未被实现；
    + 如果有必要的话，我们可以更改单例类的设置，使其可以存在一定数量的实例。
+ 加volatile关键字禁止指令重排序
+ volatile关键字：与java内存模型有关
    + 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。  
    + 禁止进行指令重排序。
    + volatile没办法保证对变量的操作的原子性。
```java

```
